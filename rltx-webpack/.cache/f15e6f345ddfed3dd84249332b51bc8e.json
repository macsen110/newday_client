{"remainingRequest":"/Users/macsen/Desktop/rltx-webpack/src/LbsLib.js","dependencies":[{"path":"/Users/macsen/Desktop/rltx-webpack/src/LbsLib.js","mtime":1511527697000},{"path":"/Users/macsen/Desktop/rltx-webpack/node_modules/_babel-loader@6.2.10@babel-loader/lib/index.js","mtime":1481808750000},{"path":"/Users/macsen/Desktop/rltx-webpack/node_modules/_cache-loader@1.2.0@cache-loader/dist/cjs.js","mtime":1510929699000}],"contextDependencies":[],"result":["/* eslint-disable no-mixed-operators */\n/* eslint-disable one-var */\n/* eslint-disable no-empty */\nexport default {\n  PI: 3.14159265358979324,\n  x_pi: 3.14159265358979324 * 3000.0 / 180.0,\n  transformLat(x, y) {\n    let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));\n    ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;\n    ret += (20.0 * Math.sin(y * this.PI) + 40.0 * Math.sin(y / 3.0 * this.PI)) * 2.0 / 3.0;\n    ret += (160.0 * Math.sin(y / 12.0 * this.PI) + 320 * Math.sin(y * this.PI / 30.0)) * 2.0 / 3.0;\n    return ret;\n  },\n  transformLon(x, y) {\n    let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));\n    ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;\n    ret += (20.0 * Math.sin(x * this.PI) + 40.0 * Math.sin(x / 3.0 * this.PI)) * 2.0 / 3.0;\n    ret += (150.0 * Math.sin(x / 12.0 * this.PI) + 300.0 * Math.sin(x / 30.0 * this.PI)) * 2.0 / 3.0;\n    return ret;\n  },\n  delta(lat, lng) {\n    const a = 6378245.0;\n    const ee = 0.00669342162296594323;\n    let dLat = this.transformLat(lng - 105.0, lat - 35.0);\n    let dLon = this.transformLon(lng - 105.0, lat - 35.0);\n    const radLat = lat / 180.0 * this.PI;\n    let magic = Math.sin(radLat);\n    magic = 1 - ee * magic * magic;\n    const sqrtMagic = Math.sqrt(magic);\n    dLat = dLat * 180.0 / (a * (1 - ee) / (magic * sqrtMagic) * this.PI);\n    dLon = dLon * 180.0 / (a / sqrtMagic * Math.cos(radLat) * this.PI);\n    return {\n      'lat': dLat,\n      'lng': dLon\n    };\n  },\n  outOfChina(lat, lng) {\n    if (lng < 72.004 || lng > 137.8347) {\n      return true;\n    }\n    if (lat < 0.8293 || lat > 55.8271) {\n      return true;\n    }\n    return false;\n  },\n  gcj_encrypt(wgsLat, wgsLon) {\n    if (this.outOfChina(wgsLat, wgsLon)) {\n      return {\n        'lat': wgsLat,\n        'lng': wgsLon\n      };\n    }\n    const d = this.delta(wgsLat, wgsLon);\n    return {\n      'lat': wgsLat + d.lat,\n      'lng': wgsLon + d.lng\n    };\n  },\n  distance(latA, lngA, latB, lngB) {\n    const earthR = 6371000,\n      x = Math.cos(latA * this.PI / 180) * Math.cos(latB * this.PI / 180) * Math.cos((lngA - lngB) * this.PI / 180),\n      y = Math.sin(latA * this.PI / 180) * Math.sin(latB * this.PI / 180);\n    let s = x + y;\n    if (s > 1) {\n      s = 1;\n    }\n    if (s < -1) {\n      s = -1;\n    }\n    const alpha = Math.acos(s),\n      distance = alpha * earthR;\n    return distance;\n  },\n  bd_encrypt(gcjLat, gcjLon) {\n    const x = gcjLon;\n    const y = gcjLat;\n    const z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);\n    const theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);\n    const bdLon = z * Math.cos(theta) + 0.0065;\n    const bdLat = z * Math.sin(theta) + 0.006;\n    return {\n      'lat': bdLat,\n      'lng': bdLon\n    };\n  },\n  transformPoint(point) {\n    // const pointArray = points;\n    // const len = pointArray.length;\n    // for (let i = 0; i < len; i += 1) {\n    //   if (pointArray[i].lng && pointArray[i].lat) {\n    //     const gcj = this.gcj_encrypt(pointArray[i].lat, pointArray[i].lng);\n    //     const baidu = this.bd_encrypt(gcj.lat, gcj.lng);\n    //     pointArray[i].lng = baidu.lng;\n    //     pointArray[i].lat = baidu.lat;\n    //   } else {\n    //     pointArray.splice(i, 1);\n    //   }\n    // }\n    // return pointArray;\n    if (point.lng && point.lat) {\n      const gcj = this.gcj_encrypt(point.lat, point.lng);\n      const baidu = this.bd_encrypt(gcj.lat, gcj.lng);\n      // point.lng = baidu.lng;\n      // point.lat = baidu.lat;\n      return baidu;\n    }\n    return point;\n  },\n  transformPoints(points) {\n    const pointArray = points;\n    const len = pointArray.length;\n    for (let i = 0; i < len; i += 1) {\n      if (pointArray[i].lng && pointArray[i].lat) {\n        const gcj = this.gcj_encrypt(pointArray[i].lat, pointArray[i].lng);\n        const baidu = this.bd_encrypt(gcj.lat, gcj.lng);\n        pointArray[i].lng = baidu.lng;\n        pointArray[i].lat = baidu.lat;\n      } else {\n        pointArray.splice(i, 1);\n      }\n    }\n    return pointArray;\n  },\n  delRepeat(array) {\n    const len = array.length;\n    if (len > 1) {\n      const arr = [];\n      array.forEach((a) => {\n        a.pos_str = '查看位置';\n        a.directionDec = this.getDirection(a.direction);\n        a.stop_point = !!a.stop_time;\n      }, this);\n\n      arr.push(array[0]);\n      for (let i = 1; i < len - 2; i++) {\n        for (let j = i + 1; j < len; j++) {\n          if (array[i].lng === array[j].lng && array[i].lat === array[j].lat) {\n          } else {\n            arr.push(array[j]);\n            i = j;\n            break;\n          }\n        }\n      }\n      return arr;\n    }\n    return array;\n  },\n  getDirection(direction) {\n    switch (true) {\n      case direction === 0:\n        return '北方';\n      case direction === 90:\n        return '东方';\n      case direction === 180:\n        return '南方';\n      case direction === 270:\n        return '西方';\n      case direction === 45:\n        return '东北方';\n      case direction === 135:\n        return '东南方';\n      case direction === 225:\n        return '西南方';\n      case direction === 315:\n        return '西北方';\n      case direction > 0 && direction < 45:\n        return '东北方偏北';\n      case direction > 45 && direction < 90:\n        return '东北方偏东';\n      case direction > 90 && direction < 135:\n        return '东南方偏东';\n      case direction > 135 && direction < 180:\n        return '东南方偏南';\n      case direction > 180 && direction < 225:\n        return '西南方偏南';\n      case direction > 225 && direction < 270:\n        return '西南方偏西';\n      case direction > 270 && direction < 315:\n        return '西北方偏西';\n      case direction > 315 && direction < 360:\n        return '西北方偏北';\n      default:\n        return '西北方偏北';\n    }\n  }\n};\n",null]}